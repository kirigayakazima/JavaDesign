(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{202:function(t,a,r){"use strict";r.r(a);var e=r(0),s=Object(e.a)({},function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"各种原则介绍"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#各种原则介绍","aria-hidden":"true"}},[t._v("#")]),t._v(" 各种原则介绍")]),t._v(" "),r("h2",{attrs:{id:"一、单一职责原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一、单一职责原则","aria-hidden":"true"}},[t._v("#")]),t._v(" 一、单一职责原则")]),t._v(" "),r("p",[t._v("就一个类而言，应该仅有一个引起它变化的原则，封装要得体，只暴露对外的公有接口，提高数据的安全性，同时也要保证类的统一和多样")]),t._v(" "),r("h2",{attrs:{id:"二、开放封闭原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二、开放封闭原则","aria-hidden":"true"}},[t._v("#")]),t._v(" 二、开放封闭原则")]),t._v(" "),r("p",[t._v("对于拓展来说是开放的，对于更改来说是封闭的。\n在实现需求的时候，需要为预计以后的需求，将可能变为需求的地方事先抽象分离出来，为以后做准备,在原有代码基础上尽可能的只拓展,而不修改原代码")]),t._v(" "),r("h2",{attrs:{id:"三、依赖倒转原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#三、依赖倒转原则","aria-hidden":"true"}},[t._v("#")]),t._v(" 三、依赖倒转原则")]),t._v(" "),r("p",[t._v("抽象不应该依赖于细节,细节应该依赖于抽象,高层模块不依赖于底层模块要针对接口进行编程,而不是针对实现进行编程")]),t._v(" "),r("h2",{attrs:{id:"四、里氏代换原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#四、里氏代换原则","aria-hidden":"true"}},[t._v("#")]),t._v(" 四、里氏代换原则")]),t._v(" "),r("p",[t._v("简单的理解为子类继承父类的时候，子类可以以父类的身份出现，只有当子类可以替换掉父类的时候，软件单位的功能不受到影响的时候，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。")])])},[],!1,null,null,null);a.default=s.exports}}]);